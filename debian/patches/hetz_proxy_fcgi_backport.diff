Backport proxy_fcgi from 2.4.26
Index: apache2/modules/proxy/mod_proxy_fcgi.c
===================================================================
--- apache2.orig/modules/proxy/mod_proxy_fcgi.c
+++ apache2/modules/proxy/mod_proxy_fcgi.c
@@ -17,13 +17,38 @@
 #include "mod_proxy.h"
 #include "util_fcgi.h"
 #include "util_script.h"
+#include "ap_expr.h"
 
 module AP_MODULE_DECLARE_DATA proxy_fcgi_module;
 
 typedef struct {
+    ap_expr_info_t *cond;
+    ap_expr_info_t *subst;
+    const char *envname;
+} sei_entry;
+
+typedef struct {
     int need_dirwalk;
 } fcgi_req_config_t;
 
+/* We will assume FPM, but still differentiate */
+typedef enum {
+    BACKEND_DEFAULT_UNKNOWN = 0,
+    BACKEND_FPM,
+    BACKEND_GENERIC,
+} fcgi_backend_t;
+
+
+#define FCGI_MAY_BE_FPM(dconf)                              \
+        (dconf &&                                           \
+        ((dconf->backend_type == BACKEND_DEFAULT_UNKNOWN) || \
+        (dconf->backend_type == BACKEND_FPM)))
+
+typedef struct {
+    fcgi_backend_t backend_type;
+    apr_array_header_t *env_fixups;
+} fcgi_dirconf_t;
+
 /*
  * Canonicalise http-like URLs.
  * scheme is the scheme for the URL
@@ -39,7 +64,7 @@ static int proxy_fcgi_canon(request_rec
     fcgi_req_config_t *rconf = NULL;
     const char *pathinfo_type = NULL;
 
-    if (strncasecmp(url, "fcgi:", 5) == 0) {
+    if (ap_cstr_casecmpn(url, "fcgi:", 5) == 0) {
         url += 5;
     }
     else {
@@ -84,45 +109,45 @@ static int proxy_fcgi_canon(request_rec
                   "set r->filename to %s", r->filename);
 
     rconf = ap_get_module_config(r->request_config, &proxy_fcgi_module);
-    if (rconf == NULL) { 
+    if (rconf == NULL) {
         rconf = apr_pcalloc(r->pool, sizeof(fcgi_req_config_t));
         ap_set_module_config(r->request_config, &proxy_fcgi_module, rconf);
     }
 
     if (NULL != (pathinfo_type = apr_table_get(r->subprocess_env, "proxy-fcgi-pathinfo"))) {
         /* It has to be on disk for this to work */
-        if (!strcasecmp(pathinfo_type, "full")) { 
+        if (!strcasecmp(pathinfo_type, "full")) {
             rconf->need_dirwalk = 1;
             ap_unescape_url_keep2f(path, 0);
         }
-        else if (!strcasecmp(pathinfo_type, "first-dot")) { 
+        else if (!strcasecmp(pathinfo_type, "first-dot")) {
             char *split = ap_strchr(path, '.');
-            if (split) { 
+            if (split) {
                 char *slash = ap_strchr(split, '/');
-                if (slash) { 
+                if (slash) {
                     r->path_info = apr_pstrdup(r->pool, slash);
                     ap_unescape_url_keep2f(r->path_info, 0);
                     *slash = '\0'; /* truncate path */
                 }
             }
         }
-        else if (!strcasecmp(pathinfo_type, "last-dot")) { 
+        else if (!strcasecmp(pathinfo_type, "last-dot")) {
             char *split = ap_strrchr(path, '.');
-            if (split) { 
+            if (split) {
                 char *slash = ap_strchr(split, '/');
-                if (slash) { 
+                if (slash) {
                     r->path_info = apr_pstrdup(r->pool, slash);
                     ap_unescape_url_keep2f(r->path_info, 0);
                     *slash = '\0'; /* truncate path */
                 }
             }
         }
-        else { 
+        else {
             /* before proxy-fcgi-pathinfo had multi-values. This requires the
              * the FCGI server to fixup PATH_INFO because it's the entire path
              */
             r->path_info = apr_pstrcat(r->pool, "/", path, NULL);
-            if (!strcasecmp(pathinfo_type, "unescape")) { 
+            if (!strcasecmp(pathinfo_type, "unescape")) {
                 ap_unescape_url_keep2f(r->path_info, 0);
             }
             ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01061)
@@ -133,6 +158,49 @@ static int proxy_fcgi_canon(request_rec
     return OK;
 }
 
+
+/*
+  ProxyFCGISetEnvIf "reqenv('PATH_INFO') =~ m#/foo(\d+)\.php$#" COVENV1 "$1"
+  ProxyFCGISetEnvIf "reqenv('PATH_INFO') =~ m#/foo(\d+)\.php$#" PATH_INFO "/foo.php"
+  ProxyFCGISetEnvIf "reqenv('PATH_TRANSLATED') =~ m#(/.*foo)(\d+)(.*)#" PATH_TRANSLATED "$1$3"
+*/
+static void fix_cgivars(request_rec *r, fcgi_dirconf_t *dconf)
+{
+    sei_entry *entries;
+    const char *err, *src;
+    int i = 0, rc = 0;
+    ap_regmatch_t regm[AP_MAX_REG_MATCH];
+
+    entries = (sei_entry *) dconf->env_fixups->elts;
+    for (i = 0; i < dconf->env_fixups->nelts; i++) {
+        sei_entry *entry = &entries[i];
+
+        if (entry->envname[0] == '!') {
+            apr_table_unset(r->subprocess_env, entry->envname+1);
+        }
+        else if (0 < (rc = ap_expr_exec_re(r, entry->cond, AP_MAX_REG_MATCH, regm, &src, &err)))  {
+            const char *val = ap_expr_str_exec_re(r, entry->subst, AP_MAX_REG_MATCH, regm, &src, &err);
+            if (err) {
+                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(03514)
+                              "Error evaluating expression for replacement of %s: '%s'",
+                               entry->envname, err);
+                continue;
+            }
+            if (APLOGrtrace4(r)) {
+                const char *oldval = apr_table_get(r->subprocess_env, entry->envname);
+                ap_log_rerror(APLOG_MARK, APLOG_TRACE4, 0, r,
+                              "fix_cgivars: override %s from '%s' to '%s'",
+                              entry->envname, oldval, val);
+
+            }
+            apr_table_setn(r->subprocess_env, entry->envname, val);
+        }
+        else {
+            ap_log_rerror(APLOG_MARK, APLOG_TRACE8, 0, r, "fix_cgivars: Condition returned %d", rc);
+        }
+    }
+}
+
 /* Wrapper for apr_socket_sendv that handles updating the worker stats. */
 static apr_status_t send_data(proxy_conn_rec *conn,
                               struct iovec *vec,
@@ -253,10 +321,12 @@ static apr_status_t send_environment(pro
     apr_status_t rv;
     apr_size_t avail_len, len, required_len;
     int next_elem, starting_elem;
+    int fpm = 0;
     fcgi_req_config_t *rconf = ap_get_module_config(r->request_config, &proxy_fcgi_module);
+    fcgi_dirconf_t *dconf = ap_get_module_config(r->per_dir_config, &proxy_fcgi_module);
 
-    if (rconf) { 
-       if (rconf->need_dirwalk) { 
+    if (rconf) {
+       if (rconf->need_dirwalk) {
           ap_directory_walk(r);
        }
     }
@@ -268,15 +338,24 @@ static apr_status_t send_environment(pro
         if (!strncmp(r->filename, "proxy:balancer://", 17)) {
             newfname = apr_pstrdup(r->pool, r->filename+17);
         }
-        else if (!strncmp(r->filename, "proxy:fcgi://", 13)) {
-            newfname = apr_pstrdup(r->pool, r->filename+13);
-        }
-        /* Query string in environment only */
-        if (newfname && r->args && *r->args) { 
-            char *qs = strrchr(newfname, '?');
-            if (qs && !strcmp(qs+1, r->args)) { 
-                *qs = '\0';
+
+        if (!FCGI_MAY_BE_FPM(dconf))  {
+            if (!strncmp(r->filename, "proxy:fcgi://", 13)) {
+                /* If we strip this under FPM, and any internal redirect occurs
+                 * on PATH_INFO, FPM may use PATH_TRANSLATED instead of
+                 * SCRIPT_FILENAME (a la mod_fastcgi + Action).
+                 */
+                newfname = apr_pstrdup(r->pool, r->filename+13);
+            }
+            /* Query string in environment only */
+            if (newfname && r->args && *r->args) {
+                char *qs = strrchr(newfname, '?');
+                if (qs && !strcmp(qs+1, r->args)) {
+                    *qs = '\0';
+                }
             }
+        } else {
+            fpm = 1;
         }
 
         if (newfname) {
@@ -285,11 +364,43 @@ static apr_status_t send_environment(pro
         }
     }
 
+#if 0
+    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(09999)
+                  "r->filename: %s", (r->filename ? r->filename : "nil"));
+    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(09999)
+                  "r->uri: %s", (r->uri ? r->uri : "nil"));
+    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(09999)
+                  "r->path_info: %s", (r->path_info ? r->path_info : "nil"));
+#endif
+
     ap_add_common_vars(r);
     ap_add_cgi_vars(r);
- 
+
+    if (fpm || apr_table_get(r->notes, "virtual_script")) {
+        /*
+         * Adjust SCRIPT_NAME, PATH_INFO and PATH_TRANSLATED for PHP-FPM
+         * TODO: Right now, PATH_INFO and PATH_TRANSLATED look OK...
+         */
+        const char *pend;
+        const char *script_name = apr_table_get(r->subprocess_env, "SCRIPT_NAME");
+        pend = script_name + strlen(script_name);
+        if (r->path_info && *r->path_info) {
+            pend = script_name + ap_find_path_info(script_name, r->path_info) - 1;
+        }
+        while (pend != script_name && *pend != '/') {
+            pend--;
+        }
+        apr_table_setn(r->subprocess_env, "SCRIPT_NAME", pend);
+        ap_log_rerror(APLOG_MARK, APLOG_TRACE4, 0, r,
+                      "fpm:virtual_script: Modified SCRIPT_NAME to: %s",
+                      pend);
+    }
+
     /* XXX are there any FastCGI specific env vars we need to send? */
 
+    /* Give admins final option to fine-tune env vars */
+    fix_cgivars(r, dconf);
+
     /* XXX mod_cgi/mod_cgid use ap_create_environment here, which fills in
      *     the TZ value specially.  We could use that, but it would mean
      *     parsing the key/value pairs back OUT of the allocated env array,
@@ -301,7 +412,7 @@ static apr_status_t send_environment(pro
 
     if (APLOGrtrace8(r)) {
         int i;
-        
+
         for (i = 0; i < envarr->nelts; ++i) {
             ap_log_rerror(APLOG_MARK, APLOG_TRACE8, 0, r, APLOGNO(01062)
                           "sending env var '%s' value '%s'",
@@ -861,7 +972,7 @@ static int fcgi_do_request(apr_pool_t *p
          * sending the response, don't return a HTTP_SERVICE_UNAVAILABLE, since
          * this is not a backend problem. */
         if (r->connection->aborted) {
-            ap_log_rerror(APLOG_MARK, APLOG_TRACE1, rv, r, 
+            ap_log_rerror(APLOG_MARK, APLOG_TRACE1, rv, r,
                           "The client aborted the connection.");
             conn->close = 1;
             return OK;
@@ -880,6 +991,9 @@ static int fcgi_do_request(apr_pool_t *p
         if (bad_request) {
             return ap_map_http_request_error(rv, HTTP_BAD_REQUEST);
         }
+        if (APR_STATUS_IS_TIMEUP(rv)) {
+            return HTTP_GATEWAY_TIME_OUT;
+        }
         return HTTP_SERVICE_UNAVAILABLE;
     }
 
@@ -912,7 +1026,7 @@ static int proxy_fcgi_handler(request_re
                   "url: %s proxyname: %s proxyport: %d",
                   url, proxyname, proxyport);
 
-    if (strncasecmp(url, "fcgi:", 5) != 0) {
+    if (ap_cstr_casecmpn(url, "fcgi:", 5) != 0) {
         ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01077) "declining URL %s", url);
         return DECLINED;
     }
@@ -943,12 +1057,12 @@ static int proxy_fcgi_handler(request_re
     }
 
     /* This scheme handler does not reuse connections by default, to
-     * avoid tying up a fastcgi that isn't expecting to work on 
+     * avoid tying up a fastcgi that isn't expecting to work on
      * parallel requests.  But if the user went out of their way to
      * type the default value of disablereuse=off, we'll allow it.
-     */  
+     */
     backend->close = 1;
-    if (worker->s->disablereuse_set && !worker->s->disablereuse) { 
+    if (worker->s->disablereuse_set && !worker->s->disablereuse) {
         backend->close = 0;
     }
 
@@ -973,18 +1087,120 @@ cleanup:
     return status;
 }
 
+static void *fcgi_create_dconf(apr_pool_t *p, char *path)
+{
+    fcgi_dirconf_t *a;
+
+    a = (fcgi_dirconf_t *)apr_pcalloc(p, sizeof(fcgi_dirconf_t));
+    a->backend_type = BACKEND_DEFAULT_UNKNOWN;
+    a->env_fixups = apr_array_make(p, 20, sizeof(sei_entry));
+
+    return a;
+}
+
+static void *fcgi_merge_dconf(apr_pool_t *p, void *basev, void *overridesv)
+{
+    fcgi_dirconf_t *a, *base, *over;
+
+    a     = (fcgi_dirconf_t *)apr_pcalloc(p, sizeof(fcgi_dirconf_t));
+    base  = (fcgi_dirconf_t *)basev;
+    over  = (fcgi_dirconf_t *)overridesv;
+
+    a->backend_type = (over->backend_type != BACKEND_DEFAULT_UNKNOWN)
+                      ? over->backend_type
+                      : base->backend_type;
+    a->env_fixups = apr_array_append(p, base->env_fixups, over->env_fixups);
+    return a;
+}
+
+static const char *cmd_servertype(cmd_parms *cmd, void *in_dconf,
+                                   const char *val)
+{
+    fcgi_dirconf_t *dconf = in_dconf;
+
+    if (!strcasecmp(val, "GENERIC")) {
+       dconf->backend_type = BACKEND_GENERIC;
+    }
+    else if (!strcasecmp(val, "FPM")) {
+       dconf->backend_type = BACKEND_FPM;
+    }
+    else {
+        return "ProxyFCGIBackendType requires one of the following arguments: "
+               "'GENERIC', 'FPM'";
+    }
+
+    return NULL;
+}
+
+
+static const char *cmd_setenv(cmd_parms *cmd, void *in_dconf,
+                              const char *arg1, const char *arg2,
+                              const char *arg3)
+{
+    fcgi_dirconf_t *dconf = in_dconf;
+    const char *err;
+    sei_entry *new;
+    const char *envvar = arg2;
+
+    new = apr_array_push(dconf->env_fixups);
+    new->cond = ap_expr_parse_cmd(cmd, arg1, 0, &err, NULL);
+    if (err) {
+        return apr_psprintf(cmd->pool, "Could not parse expression \"%s\": %s",
+                            arg1, err);
+    }
+
+    if (envvar[0] == '!') {
+        /* Unset mode. */
+        if (arg3) {
+            return apr_psprintf(cmd->pool, "Third argument (\"%s\") is not "
+                                "allowed when using ProxyFCGISetEnvIf's unset "
+                                "mode (%s)", arg3, envvar);
+        }
+        else if (!envvar[1]) {
+            /* i.e. someone tried to give us a name of just "!" */
+            return "ProxyFCGISetEnvIf: \"!\" is not a valid variable name";
+        }
+
+        new->subst = NULL;
+    }
+    else {
+        /* Set mode. */
+        if (!arg3) {
+            /* A missing expr-value should be treated as empty. */
+            arg3 = "";
+        }
+
+        new->subst = ap_expr_parse_cmd(cmd, arg3, AP_EXPR_FLAG_STRING_RESULT, &err, NULL);
+        if (err) {
+            return apr_psprintf(cmd->pool, "Could not parse expression \"%s\": %s",
+                                arg3, err);
+        }
+    }
+
+    new->envname = envvar;
+
+    return NULL;
+}
 static void register_hooks(apr_pool_t *p)
 {
     proxy_hook_scheme_handler(proxy_fcgi_handler, NULL, NULL, APR_HOOK_FIRST);
     proxy_hook_canon_handler(proxy_fcgi_canon, NULL, NULL, APR_HOOK_FIRST);
 }
 
+static const command_rec command_table[] = {
+    AP_INIT_TAKE1("ProxyFCGIBackendType", cmd_servertype, NULL, OR_FILEINFO,
+                  "Specify the type of FastCGI server: 'Generic', 'FPM'"),
+    AP_INIT_TAKE23("ProxyFCGISetEnvIf", cmd_setenv, NULL, OR_FILEINFO,
+                  "expr-condition env-name expr-value"),
+    { NULL }
+};
+
 AP_DECLARE_MODULE(proxy_fcgi) = {
     STANDARD20_MODULE_STUFF,
-    NULL,                       /* create per-directory config structure */
-    NULL,                       /* merge per-directory config structures */
+    fcgi_create_dconf,          /* create per-directory config structure */
+    fcgi_merge_dconf,           /* merge per-directory config structures */
     NULL,                       /* create per-server config structure */
     NULL,                       /* merge per-server config structures */
-    NULL,                       /* command apr_table_t */
+    command_table,              /* command apr_table_t */
     register_hooks              /* register hooks */
 };
